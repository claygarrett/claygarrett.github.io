<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="og:site_name" content="Code, Art, and Nonsense"/><link rel="canonical" href="https://your-website-url.com/posts/tuple-trouble-pushing-swifts-tuple-to-the-limit"/><meta name="twitter:url" content="https://your-website-url.com/posts/tuple-trouble-pushing-swifts-tuple-to-the-limit"/><meta name="og:url" content="https://your-website-url.com/posts/tuple-trouble-pushing-swifts-tuple-to-the-limit"/><title>Tuple Trouble: pushing Swift's tuple to the¬†limit | Code, Art, and Nonsense</title><meta name="twitter:title" content="Tuple Trouble: pushing Swift's tuple to the¬†limit | Code, Art, and Nonsense"/><meta name="og:title" content="Tuple Trouble: pushing Swift's tuple to the¬†limit | Code, Art, and Nonsense"/><meta name="description" content="Admit it. You've never been excited about the lowly tuple in Swift. Maybe it was there to comfort you when you're too lazy to write a struct. But face it. You friend-zoned the tuple a long time ago. Well, I'm here to suggest we give tuple a chance to get a little crazy. Let's make some bad coding decisions and regret it together!"/><meta name="twitter:description" content="Admit it. You've never been excited about the lowly tuple in Swift. Maybe it was there to comfort you when you're too lazy to write a struct. But face it. You friend-zoned the tuple a long time ago. Well, I'm here to suggest we give tuple a chance to get a little crazy. Let's make some bad coding decisions and regret it together!"/><meta name="og:description" content="Admit it. You've never been excited about the lowly tuple in Swift. Maybe it was there to comfort you when you're too lazy to write a struct. But face it. You friend-zoned the tuple a long time ago. Well, I'm here to suggest we give tuple a chance to get a little crazy. Let's make some bad coding decisions and regret it together!"/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Slab:wght@100;300;500;900&display=swap" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to Code, Art, and Nonsense"/></head><body class="item-page"><header><div class="wrapper"><img src="/images/claygarrett.jpg" class="header-image"/><div class="right header-title-wrapper"><a href="/" class="site-name">Code, Art, and Nonsense</a><p class="author">by Clay Garrett</p></div><div class="clear"></div></div></header><div class="wrapper"><article><div class="content"><img src="/images/post-1/header.png" alt="An image of source code that is a Tuple, containing the values ("Tuple", "Trouble""/><h1>Tuple Trouble: pushing Swift's tuple to the¬†limit</h1><p>Admit it. You've never been excited about the lowly tuple in Swift. Maybe it was there to comfort you when you were too lazy to write a struct. But face it. You friend-zoned the tuple a long time ago. Well, I'm here to suggest we give tuple a chance to get a little crazy. Let's make some bad coding decisions and regret it together!</p><h1>A 3D Tuple with 1000 things</h1><p>I'm gonna ground this exercise in a real world scenario: <em>versioning</em>. Sometimes we need to represent a software release version on our code, and that gives us a good example to explore a beautiful, bad idea. OK, so if we had our heads on straight, we'd probably just pick one of these:</p><pre><code><span class="keyword">let</span> version = <span class="string">"3.8.6"</span>
<span class="keyword">let</span> version = <span class="type">Version</span>(<span class="string">"3"</span>, <span class="string">"8"</span>, <span class="string">"6"</span>)
</code></pre><p>That'd be easy to code and understand. But we want tuple to let its hair down and have some fun. So what if we could do this instead?</p><pre><code><span class="keyword">let</span> version = v.<span class="number">3.8.6</span>
</code></pre><h2>‚úÖ Pros</h2><ul><li>It's strongly typed so we couldn't accidentally throw a letter into our version string.</li><li>It'll confuse everyone and make them think we're smart. Think of all the friends we'll make! üï∫üèº</li></ul><h2>üî¥ Cons</h2><ul><li>We've gotta do all the freakin bullshit you're about to read.</li></ul><p>The good news, is this is possible in Swift! And the secret lies in creating a <strong><em>1000 element tuple</em></strong>. Let's take a look at this train wreck waiting to happen.</p><img src="/images/post-1/trolley.png" alt="A "Trolly Problem" meme. The conductor controls which track the train will take. If he does nothing, it will run over 5 innocent bystanders. If he switches the track, he will run over one. Int his meme, the five bystanders are labeled "Exciting code" while the one bystander is labeled "Boring Code.""/><h1>ü¶∂Getting our feet¬†dirty</h1><p>Yes, I mixed the metaphor. That's the least of your problems if you made it this far. Things are about to get weird. Let's go on a little adventure together and look at tuple basics. A simple 3-element tuple containing the first three letters of the English alphabet looks like this:</p><pre><code><span class="keyword">let</span> letters = (<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>)
letters.<span class="number">0</span> <span class="comment">// A</span>
letters.<span class="number">1</span> <span class="comment">// B</span>
letters.<span class="number">2</span> <span class="comment">// C</span>
</code></pre><p>Nothing really groundbreaking or useful here. BUT! Hear me out. What if the elements in the tuple happened to be much more closely related to the index in which they appeared in the tuple.</p><pre><code><span class="keyword">let</span> numbers = (<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>)
numbers.<span class="number">0</span> <span class="comment">// 0</span>
numbers.<span class="number">1</span> <span class="comment">// 1</span>
numbers.<span class="number">2</span> <span class="comment">// 2</span>
</code></pre><p>The tuple's indices are now identical to the values they contain. You can now imagine doing useless stuff like <code>numbers.0 * numbers.1</code> which would result in <code>0</code>.</p><p><strong>"Oooooh,"</strong> you might say. <strong>"You managed to make multiplying two numbers painful!"</strong> Shut up, please. I'm trying to build a story here.</p><h1>ü§Ø Nested tuples can also be nested, numerical APIs</h1><p>What if we wanted to get more complicated and nest some tuples?</p><pre><code><span class="keyword">let</span> versionList = (
  (
    (<span class="string">"0.0.0"</span>, <span class="string">"0.0.1"</span>, <span class="string">"0.0.2"</span>),
    (<span class="string">"0.1.0"</span>, <span class="string">"0.1.1"</span>, <span class="string">"0.1.2"</span>),
    (<span class="string">"0.2.0"</span>, <span class="string">"0.2.1"</span>, <span class="string">"0.2.3"</span>)
  ),(
    (<span class="string">"1.0.0"</span>, <span class="string">"1.0.1"</span>, <span class="string">"1.0.2"</span>),
    (<span class="string">"1.1.0"</span>, <span class="string">"1.1.1"</span>, <span class="string">"1.1.2"</span>),
    (<span class="string">"1.2.0"</span>, <span class="string">"1.2.1"</span>, <span class="string">"1.2.3"</span>),
  ),(
    (<span class="string">"2.0.0"</span>, <span class="string">"2.0.1"</span>, <span class="string">"2.0.2"</span>),
    (<span class="string">"2.1.0"</span>, <span class="string">"2.1.1"</span>, <span class="string">"2.1.2"</span>),
    (<span class="string">"2.2.0"</span>, <span class="string">"2.2.1"</span>, <span class="string">"2.2.2"</span>)
  ),
)

<span class="call">print</span>(versionList.<span class="number">0.2.1</span>) <span class="comment">// "0.2.1"</span>
</code></pre><p>Pretty neat, huh? To state the obvious, this is overly complicated for the value it provides. It's a thought exercise, not a good idea. Also, an image always helps me get to where I'm going faster, so here's a clearer visualization of what that nested tuple looks like:</p><img src="/images/post-1/tuple.jpg" alt="A 3D tuple of all the possible combinations of a 3 part version with the numbers 1, 2, 3. It's visualized as parent/child graph."/><h1>Defining a üîü x üîü x üîü tuple¬†type</h1><p>A 3 x 3 tuple like the one above gives us only 27 possible version numbers. But we need 1000 version numbers to support versions 0.0.0 through 9.9.9, assuming we don't ever want a component higher than 10. This is already a horrible assumption, so I hope you've lost all faith in me by now.</p><p>So, anyway, we need a 10 x 10 x 10 tuple. ü§¶üèª‚Äç‚ôÇÔ∏è The even more terrible thing is we have to manually specify the shape of this tuple to the compiler. It needs to know that there's going to be a tuple that contains 10 tuples which each contain 10 more tuples that each that has a version number inside.</p><p><strong><em>I'm sorry I'm doing this to you. Bring me up in therapy if it helps.</em></strong></p><h2>Defining the innermost tuple</h2><p>Abstraction is sometimes our friend, so let's write a shortcut to reference the three different dimensions in our matrix of tuples. To actually represent each unique version in our tuple, we'll have an extremely simple <code>Version</code> class to hold the major/minor/revision version numbers. Our second typealias will reference the first one and the third typealias will reference the second one:</p><pre><code><span class="keyword">typealias</span> InnermostTuple = (
    <span class="type">Version</span>, <span class="type">Version</span>, <span class="type">Version</span>, <span class="type">Version</span>, <span class="type">Version</span>, 
    <span class="type">Version</span>, <span class="type">Version</span>, <span class="type">Version</span>, <span class="type">Version</span>, <span class="type">Version</span>
)
<span class="keyword">typealias</span> MiddleTuple = (
    <span class="type">InnermostTuple</span>, <span class="type">InnermostTuple</span>, <span class="type">InnermostTuple</span>, <span class="type">InnermostTuple</span>, <span class="type">InnermostTuple</span>, 
    <span class="type">InnermostTuple</span>, <span class="type">InnermostTuple</span>, <span class="type">InnermostTuple</span>, <span class="type">InnermostTuple</span>, <span class="type">InnermostTuple</span>
)
<span class="keyword">typealias</span> OutermostTuple = (
    <span class="type">MiddleTuple</span>, <span class="type">MiddleTuple</span>, <span class="type">MiddleTuple</span>, <span class="type">MiddleTuple</span>, <span class="type">MiddleTuple</span>, 
    <span class="type">MiddleTuple</span>, <span class="type">MiddleTuple</span>, <span class="type">MiddleTuple</span>, <span class="type">MiddleTuple</span>, <span class="type">MiddleTuple</span>
)
</code></pre><h2>Initializing such an unnecessarily large¬†tuple</h2><p>We now have the type we need, but how can we instantiate our mega-tuple? We can't programmatically access tuple elements via brackets like we can arrays. But there are ways to make this less verbose. Let's make a generator to create a fully populated instance of that type! üôÑ</p><p>What if there was a function that would place 10 things in a tuple for us, delegating the instantiation of those things to us, but giving us index of the element that it plans to place it in. We'd also want it to be generic because each of the 3 layers of our nested tuple hold a different type.</p><pre><code><span class="comment">/// Given a transformation function that accepts an index, create a tuple of the 10 returned items, 
/// mapping the item to the same index in the tuple.</span>
<span class="keyword">static func</span> make10TupleIndexed&lt;T&gt;(transform t: (<span class="type">Int</span>) -&gt; <span class="type">T</span>) -&gt; (<span class="type">T</span>, <span class="type">T</span>, <span class="type">T</span>, <span class="type">T</span>, <span class="type">T</span>, <span class="type">T</span>, <span class="type">T</span>, <span class="type">T</span>, <span class="type">T</span>, <span class="type">T</span>) {
     <span class="keyword">return</span> (<span class="call">t</span>(<span class="number">0</span>), <span class="call">t</span>(<span class="number">1</span>), <span class="call">t</span>(<span class="number">2</span>), <span class="call">t</span>(<span class="number">3</span>), <span class="call">t</span>(<span class="number">4</span>), <span class="call">t</span>(<span class="number">5</span>), <span class="call">t</span>(<span class="number">6</span>), <span class="call">t</span>(<span class="number">7</span>), <span class="call">t</span>(<span class="number">8</span>), <span class="call">t</span>(<span class="number">9</span>))
}
</code></pre><p>We're almost there! Now we just need to call our method once for each layer, passing in the appropriate <code>t</code> for each step. As we laid out above, the innermost steps' <code>t</code> should create a <code>Version</code> instance, and needs the index of all 3 layers to do so, to guarantee a unique <code>Version</code>.</p><p>The middle layer's <code>t</code> should create a 10-element <code>Version</code> tuple, and the outer layer's t should create a 10-element tuple of 10-element <code>Version</code> tuples. Queue the everything is fine gif.</p><pre><code><span class="keyword">typealias</span> VersionPicker = <span class="type">OutermostTuple</span>

<span class="keyword">func</span> generateVersionPicker() -&gt; <span class="type">VersionPicker</span> {
     <span class="call">make10TupleIndexed</span> { majorIndex <span class="keyword">in</span>
         <span class="call">make10TupleIndexed</span> { minorIndex <span class="keyword">in</span>
             <span class="call">make10TupleIndexed</span> { revisionIndex <span class="keyword">in</span>
                 <span class="type">Version</span>(majorIndex, minorIndex, revisionIndex)
             }
         }
     }
 }
</code></pre><h1>üòà Waking up our Frankenstein</h1><p>We're all done! Now we get to use our irresponsible creation irresponsibly!</p><pre><code><span class="keyword">let</span> v: <span class="type">VersionPicker</span> = <span class="call">generateVersionPicker</span>()
<span class="keyword">let</span> version = v.<span class="number">3.8.6</span>
<span class="call">print</span>(version)
</code></pre><p>We now have an integer-based API that feels super clean and magical. But we made our magic potion in a rusty cauldron with the tears of kittens. So let's not be <strong><em>toooooooo</em></strong> proud of ourselves. You can see a gist of the full working code below:</p><img src="https://www.orlandosentinel.com/resizer/dHErRthtB24XuILPofXAKuBGeHc=/1200x0/top/cloudfront-us-east-1.images.arcpublishing.com/tronc/NGHCLEFQCFD3XCNNNYOHH64QZQ.jpg" alt="The evil-looking "Black Cauldron" Character Dude"/><script src="https://gist.github.com/claygarrett/fcd431cb1b15c713550bf7b89942aa16.js"></script><h1>Special Thanks</h1><p>I appreciate <a href="https://twitter.com/jckarter">@jckarter</a> for putting the idea of misuing tuples in my head in the first place. And also <a href="https://www.twitter.com/@bgannin">@bgannin</a> for further inspiring this awful idea after I inspired his awful idea with my awful idea:</p><blockquote class="twitter-tweet"><p lang="en" dir="ltr">The worst way to version your API access.</p>&mdash; Brian (@bgannin) <a href="https://twitter.com/bgannin/status/1479645847092486145?ref_src=twsrc%5Etfw">January 8, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></div><span>Tagged with: </span><ul class="tag-list"><li><a href="/tags/swift">Swift</a></li><li><a href="/tags/tuple">tuple</a></li><li><a href="/tags/versioning">versioning</a></li><li><a href="/tags/bad-idea">bad idea</a></li></ul></article></div><footer><p>Generated using <a href="https://github.com/johnsundell/publish">Publish</a></p><p><a href="/feed.rss">RSS feed</a></p></footer></body></html>